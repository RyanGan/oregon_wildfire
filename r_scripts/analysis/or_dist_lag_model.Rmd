---
title: "Oregon Distributed Lag Model"
author: "Jingyang Liu"
date: "June 12, 2017"
output: html_document
---

```{r library, include=FALSE, echo=FALSE}
library(readr)
library(dplyr)
library(lubridate)
library(splines)
library(ggplot2)
library(survival)
library(htmlTable)

```

### Set up for distributed lag model

```{r set up,  include=FALSE, echo=FALSE, eval=FALSE}
read_path0 <- paste0('C:/Users/jyliu/Desktop/local_git_repo/oregon_wildfire_new/data/Oregon_PM/zip_pm_to_merge_with_acap.csv')
zip_smoke <- read_csv(read_path0) # 63801 rows

zip_smoke_w_lag <- zip_smoke %>% arrange(ZIPCODE, date) %>%
  # group by zipcode
  group_by(ZIPCODE) %>% 
  # wrf
  mutate(wrf_f_pm_lag1 = lag(wrf_f_pm, 1, order_by = ZIPCODE), 
         wrf_f_pm_lag2 = lag(wrf_f_pm, 2, order_by = ZIPCODE),
         wrf_f_pm_lag3 = lag(wrf_f_pm, 3, order_by = ZIPCODE),
         wrf_f_pm_lag4 = lag(wrf_f_pm, 4, order_by = ZIPCODE),
         wrf_f_pm_lag5 = lag(wrf_f_pm, 5, order_by = ZIPCODE),
         wrf_f_pm_lag6 = lag(wrf_f_pm, 6, order_by = ZIPCODE),
         wrf_f_pm_lag7 = lag(wrf_f_pm, 7, order_by = ZIPCODE),
         # wrf no fire lag
         wrf_nf_pm_lag1 = lag(wrf_nf_pm, 1, order_by = ZIPCODE),
         wrf_nf_pm_lag2 = lag(wrf_nf_pm, 2, order_by = ZIPCODE),
         wrf_nf_pm_lag3 = lag(wrf_nf_pm, 3, order_by = ZIPCODE),
         wrf_nf_pm_lag4 = lag(wrf_nf_pm, 4, order_by = ZIPCODE),
         wrf_nf_pm_lag5 = lag(wrf_nf_pm, 5, order_by = ZIPCODE),
         wrf_nf_pm_lag6 = lag(wrf_nf_pm, 6, order_by = ZIPCODE),
         wrf_nf_pm_lag7 = lag(wrf_nf_pm, 7, order_by = ZIPCODE),
         # wrf_smk_pm
         wrf_smk_pm_lag1 = lag(wrf_smk_pm, 1, order_by = ZIPCODE),
         wrf_smk_pm_lag2 = lag(wrf_smk_pm, 2, order_by = ZIPCODE),
         wrf_smk_pm_lag3 = lag(wrf_smk_pm, 3, order_by = ZIPCODE),
         wrf_smk_pm_lag4 = lag(wrf_smk_pm, 4, order_by = ZIPCODE),
         wrf_smk_pm_lag5 = lag(wrf_smk_pm, 5, order_by = ZIPCODE),
         wrf_smk_pm_lag6 = lag(wrf_smk_pm, 6, order_by = ZIPCODE),
         wrf_smk_pm_lag7 = lag(wrf_smk_pm, 7, order_by = ZIPCODE),
         # geo weighted pm
         geo_wt_pm_lag1 = lag(geo_wt_pm, 1, order_by = ZIPCODE),
         geo_wt_pm_lag2 = lag(geo_wt_pm, 2, order_by = ZIPCODE),
         geo_wt_pm_lag3 = lag(geo_wt_pm, 3, order_by = ZIPCODE),
         geo_wt_pm_lag4 = lag(geo_wt_pm, 4, order_by = ZIPCODE),
         geo_wt_pm_lag5 = lag(geo_wt_pm, 5, order_by = ZIPCODE),
         geo_wt_pm_lag6 = lag(geo_wt_pm, 6, order_by = ZIPCODE),
         geo_wt_pm_lag7 = lag(geo_wt_pm, 7, order_by = ZIPCODE),
         # krig pm
         krig_pm_lag1 = lag(krig_pm, 1, order_by = ZIPCODE),
         krig_pm_lag2 = lag(krig_pm, 2, order_by = ZIPCODE),
         krig_pm_lag3 = lag(krig_pm, 3, order_by = ZIPCODE),
         krig_pm_lag4 = lag(krig_pm, 4, order_by = ZIPCODE),
         krig_pm_lag5 = lag(krig_pm, 5, order_by = ZIPCODE), 
         krig_pm_lag6 = lag(krig_pm, 6, order_by = ZIPCODE),
         krig_pm_lag7 = lag(krig_pm, 7, order_by = ZIPCODE), 
         # background pm
         background_pm_lag1 = lag(background_pm, 1, order_by = ZIPCODE),
         background_pm_lag2 = lag(background_pm, 2, order_by = ZIPCODE),
         background_pm_lag3 = lag(background_pm, 3, order_by = ZIPCODE),
         background_pm_lag4 = lag(background_pm, 4, order_by = ZIPCODE),
         background_pm_lag5 = lag(background_pm, 5, order_by = ZIPCODE), 
         background_pm_lag6 = lag(background_pm, 6, order_by = ZIPCODE),
         background_pm_lag7 = lag(background_pm, 7, order_by = ZIPCODE), 
         # geo_smk_pm 
         geo_smk_pm_lag1 = lag(geo_smk_pm, 1, order_by = ZIPCODE),
         geo_smk_pm_lag2 = lag(geo_smk_pm, 2, order_by = ZIPCODE),
         geo_smk_pm_lag3 = lag(geo_smk_pm, 3, order_by = ZIPCODE),
         geo_smk_pm_lag4 = lag(geo_smk_pm, 4, order_by = ZIPCODE),
         geo_smk_pm_lag5 = lag(geo_smk_pm, 5, order_by = ZIPCODE),
         geo_smk_pm_lag6 = lag(geo_smk_pm, 6, order_by = ZIPCODE),
         geo_smk_pm_lag7 = lag(geo_smk_pm, 7, order_by = ZIPCODE),
         # krig smk pm
         krig_smk_pm_lag1 = lag(krig_smk_pm, 1, order_by = ZIPCODE),
         krig_smk_pm_lag2 = lag(krig_smk_pm, 2, order_by = ZIPCODE),
         krig_smk_pm_lag3 = lag(krig_smk_pm, 3, order_by = ZIPCODE),
         krig_smk_pm_lag4 = lag(krig_smk_pm, 4, order_by = ZIPCODE),
         krig_smk_pm_lag5 = lag(krig_smk_pm, 5, order_by = ZIPCODE),
         krig_smk_pm_lag6 = lag(krig_smk_pm, 6, order_by = ZIPCODE),
         krig_smk_pm_lag7 = lag(krig_smk_pm, 7, order_by = ZIPCODE),
         # temp
         wrf_temp_lag1 = lag(wrf_temp, 1, order_by = ZIPCODE),
         wrf_temp_lag2 = lag(wrf_temp, 2, order_by = ZIPCODE),
         wrf_temp_lag3 = lag(wrf_temp, 3, order_by = ZIPCODE),
         wrf_temp_lag4 = lag(wrf_temp, 4, order_by = ZIPCODE),
         wrf_temp_lag5 = lag(wrf_temp, 5, order_by = ZIPCODE), 
         wrf_temp_lag6 = lag(wrf_temp, 6, order_by = ZIPCODE),
         wrf_temp_lag7 = lag(wrf_temp, 7, order_by = ZIPCODE)) %>% 
  # ungroup by zip
  ungroup(ZIPCODE) %>% 
  # attach a zip indicator for each smoke variable
  setNames(paste(colnames(.), "zip", sep="_"))  %>% 
  # remove the '_zip' from the zipcode and date variable 
  rename(ZIPCODE = ZIPCODE_zip, date = date_zip)

# set variable list
var_list <- c('respiratory', 'asthma', 'pneumonia',  'acute_bronch', 'copd', 
              'cvd', 'isch_heart_dis', 'arrhythmia', 'heart_failure', 
              'cerbrovas_dis', 'myocardial_infarc', 'broken_arm')

start <- Sys.time()
for(j in var_list) { # begin first loop of variable names (outcomes)
  
  # standard for statement without parallel computing
  #for(j in 1:length(var_list)){
  read_path <- paste('../data_new/casecrossover/or', j, 'may_to_sep_casecross.csv', sep='_')
  or_disease <- read_csv(read_path)
  
  ### try join
  colnames(or_disease)[24] <- c("ZIPCODE")
  colnames(or_disease)[74] <- c("date")
  
  outcome_casecross <- or_disease %>%
    # indicator for male=0, female=1, unknown = 2
    mutate(age = 2013-yob,
           sex_ind =ifelse(gender == "F", 1, 
                           ifelse(gender == "M", 0, 2)),
           age_ind = ifelse(age < 15, 0,
                            ifelse(age >= 15 & age < 65, 1,
                                   ifelse(age >= 65 & age <=105, 2, NA)))
    ) %>% # end of mutate 
    # create variables
    mutate(day = as.factor(weekdays(fromdate)),
           day_admit = as.factor(weekdays(date)),
           month_smk = month(fromdate),
           month_admit = month(date),
           season_smk = ifelse(fromdate >= "2013-03-20" &  
                                 fromdate <= "2013-06-21", "spring",
                               ifelse(fromdate >= "2013-06-22" &  
                                        fromdate <= "2013-09-22", "summer",
                                      ifelse(fromdate >= "2013-09-23" & 
                                               fromdate <= "2013-12-21", "fall", "other"))),
           season_admit = ifelse(date >= "2013-03-20" &  
                                   date <= "2013-06-21", "spring",
                                 ifelse(date >= "2013-06-22" &  
                                          date <= "2013-09-22", "summer",
                                        ifelse(date >= "2013-09-23" & 
                                                 date <= "2013-12-21", "fall", "other")))) %>%
    # join with zip-level pm estimates
    left_join(zip_smoke_w_lag, by = c("date", "ZIPCODE"))%>%
    arrange(personkey, fromdate) # order by id and fromdate
  
  
  
  
  # checks
  # glimpse(outcome_casecross)
  # which(colnames(outcome_casecross)=='geo_wt_pm_zip')
  # check <- outcome_casecross[, c(1:16, 20, 89, 111:133)]
  
  # Create a permanent case-cross over datasets
  file_name <- paste0('../data_new/casecrossover/dist_lag/or_', j, '_may_to_sep_dist_lag_casecross.csv')
  
  # write permanent dataset
  write_csv(outcome_casecross, file_name)
  
} # End of the overall loop

total_time <- Sys.time() - start
total_time #  9.131646 mins
```


### Distributed Lag Model

For asthma outcomes with 7 lags totally. Use GWR method.

```{r DLM}
path <- paste0("../data_new/casecrossover/dist_lag")

# asthma
asthma_casecross <- read_csv(paste(path, 
                                   "or_asthma_may_to_sep_dist_lag_casecross.csv", 
                                   sep = "/")) 

asthma_lag <- asthma_casecross %>%
  filter(gender!="U") %>%
  filter(outcome==1) %>%
  select(89, 116:122) # GWR-method

which(colnames(asthma_casecross)=="geo_wt_pm_zip") # 89
which(colnames(asthma_casecross)=="geo_wt_pm_lag1_zip") #116

lag_max <- 7
n <- length(asthma_lag[,1])

asthma_lag <- as.matrix(asthma_lag)

# true DL function
DLfunc <- exp(-(0:lag_max)/2)

# simulate outcomes
y <- drop(asthma_lag%*%DLfunc) # + rnorm(n)

B <- ns(0:lag_max, df =4, intercept=TRUE)

# the nrow B should equal ncol(pm)
dim(B)
dim(asthma_lag)

asthma_lag_B <- asthma_lag%*%B
fit <- lm(y~asthma_lag_B)
coef(fit)


dlparms <- grep("asthma_lag_B",names(coef(fit)))
DLestimate<- data.frame(estimate=B%*%coef(fit)[dlparms])
DLvar <- B%*%vcov(fit)[dlparms,dlparms]%*%t(B)
DLestimate$SE <- sqrt(diag(DLvar))
DLestimate$lower <- DLestimate$estimate + DLestimate$SE * qt(1-0.975, df=fit$df.residual)
DLestimate$upper <- DLestimate$estimate + DLestimate$SE * qt(0.975, df=fit$df.residual)
DLestimate

DLestimate$lag <- 0:lag_max
DLestimate$truth <- DLfunc
p <- ggplot(DLestimate, aes(x=lag, y=estimate, ymin=lower, ymax=upper))
p <- p + geom_ribbon(alpha=.5) + geom_line(size=2)
p <- p + geom_line(aes(x=lag, y=truth), linetype=2, size=2)
p <- p + theme_bw()
p


cumulative <- sum(DLestimate$estimate)
cumulative
## [1] 2.489717
cumulative_se <- sqrt(sum(DLvar))
cumulative_se
## [1] 0.0007685608
cumulative_CI <- cumulative + cumulative_se * qt(c(1-0.975,0.975), df=fit$df.residual)
cumulative_CI
## [1] 2.488209 2.491224

```

### Analysis

```{r load data, include=FALSE, echo=FALSE,}
resp_casecross <- read_csv(paste(path, 
                                 "or_respiratory_may_to_sep_dist_lag_casecross.csv", 
                                 sep = "/"))

# asthma
# asthma_casecross <- read_csv(paste(path, 
#                                    "or_asthma_may_to_sep_time_strat_casecross_both.csv", 
#                                    sep = "/")) 

# copd 
copd_casecross <- read_csv(paste(path, 
                                 "or_copd_may_to_sep_dist_lag_casecross.csv", 
                                 sep = "/"))

# pneum or bronchitis
pneum_casecross <- read_csv(paste(path, 
                                  "or_pneumonia_may_to_sep_dist_lag_casecross.csv",
                                  sep="/"))
 # acute bronchitis
acute_bronch_casecross <- read_csv(paste(path, 
                                         "or_acute_bronch_may_to_sep_dist_lag_casecross.csv",
                                         sep = "/"))
# cvd
cvd_casecross <- read_csv(paste(path, 
                                "or_cvd_may_to_sep_dist_lag_casecross.csv",
                                sep="/"))
# arrhythmia
arrhythmia_casecross <- read_csv(paste(path, 
                                       "or_arrhythmia_may_to_sep_dist_lag_casecross.csv",
                                       sep="/"))
# cerebral vascular
cereb_vas_casecross <- read_csv(paste(path, 
                                      "or_cerbrovas_dis_may_to_sep_dist_lag_casecross.csv",
                                      sep="/"))
# heart failure
hf_casecross <- read_csv(paste(path, 
                               "or_heart_failure_may_to_sep_dist_lag_casecross.csv", 
                               sep="/"))
# ischemic heart disease
ihd_casecross <- read_csv(paste(path, 
                                "or_isch_heart_dis_may_to_sep_dist_lag_casecross.csv",
                                sep="/"))
# myo infarc
mi_casecross <- read_csv(paste(path, 
                               "or_myocardial_infarc_may_to_sep_dist_lag_casecross.csv", sep="/"))

# broken arm
broken_arm_casecross <- read_csv(paste(path, 
                                       "or_broken_arm_may_to_sep_dist_lag_casecross.csv",
                                       sep="/"))

```


```{r lag1}
df_list <- list(resp_casecross, asthma_casecross, copd_casecross, 
                pneum_casecross, acute_bronch_casecross, cvd_casecross, arrhythmia_casecross,
                cereb_vas_casecross, hf_casecross, ihd_casecross, mi_casecross, 
                broken_arm_casecross)

outcome_list <- c('All Respiratory', 'Asthma', 'COPD', 
                  'Pneumonia', 'Acute Bronchitis', 'Cardiovascular Disease',
                  'Arrhythmia', 'Cerebrovascular Disease', 'Heart Failure',
                  'Ischemic Heart Disease', 'Myocardial Infarction',
                  'Broken Arm')

method_list <- c('WRF-Chem Smoke Lag 1', 'Kriging Smoke Lag 1', 'Geo-Weighted Smoke Lag 1')

# create an empty list to row bind dataframes together
datalist <- list()

# data wrangling ----
# Producing conditional logit model estimates loop 
for(i in 1:length(df_list)){
  
  # dataframe to loop through
  df_to_loop <- data.frame(df_list[i])
  # indication of column
  outcome <- colnames(df_to_loop[76])
  # outcome name
  outcome_name <- outcome_list[i]
  
  # extract covariates from dataframe
  covariates_df <- df_to_loop[, c(1:26, 71, 74, 76:85)]
  
  # extract pm values and divide by 10 and ordered
  which(colnames(df_to_loop)=="wrf_smk_pm_lag1_zip") # 109
  which(colnames(df_to_loop)=="krig_pm_lag1_zip") # 123
  which(colnames(df_to_loop)=="geo_wt_pm_lag1_zip") # code to find column numbers, 116
  pm_estimates_df <- df_to_loop[, c(109,123,116, 94)]/10  # create 10 unit increases
  
  # dataframe for analysis creation
  # bind columns back together 
  df_analysis <- cbind(covariates_df, pm_estimates_df) %>%
    # remove missing pm values
    filter(!is.na(wrf_smk_pm_lag1_zip)) %>% 
    filter(!is.na(krig_pm_lag1_zip)) %>% 
    filter(!is.na(geo_wt_pm_lag1_zip)) %>% 
    
    # join in cdc met data
    # full_join(daily_zip_met, by = c("ZIPCODE", "date")) %>% 
    # the following code makes sure that the counterfactual values retained are 
    # symetric in that number of obs before = number of obs after
    mutate(obs_diff_admission = (fromdate - date)/7) 
  # dataframe is already for the entire fire season, so I don't need to subset anymore
  
  
  # empty df for table
  table_df <- data.frame()
  
  # empty matrix
  point_estimates <- matrix(nrow = 3, ncol = 9, byrow = T)
  
  colnames(point_estimates) <- c('outcome', 'pm_method', 'n', 'n_events', 'odds_ratio', 
                                 'lower95', 'upper95', 'se', 'p_val')
  
  # fill in the outcome name for the dataframe before the loop
  point_estimates[, 1] <- outcome_name
  
  
  # second loop to run a model for each pm estimation method
  for(j in 39:41){
    
    # variable to model 
    var_name <- colnames(df_analysis[j])
    
    # conditional logistic regression model
    mod <- clogit(outcome ~ df_analysis[[j]] + wrf_temp_zip + strata(personkey), df_analysis)
    
    # some model/DAG checks of data rish provided
    
    #glimpse(df_analysis)
    
    # adjusting for admit month is not possible as it's the same var for the subject.
    # adjusting for month smoke is a collider and should not be adjusted for.
    #summary(clogit(outcome ~ geo_smk_pm_zip + daily_meanRH + daily_meanT + daily_meanWS + daily_meanPrcp +
    #                as.factor(month_smk) + strata(PATIENTID), df_analysis))
    #outocme association: daily_meanRH, 
    
    # check for confoudning following DAG assumptions
    #summary(clogit(outcome ~ wrf_temp_zip + strata(PATIENTID), df_analysis))
    #summary(clogit(outcome ~ wrf_temp_zip + strata(PATIENTID), df_analysis))
    # smoke predictor association: daily_meanRH, 
    #summary(lmer(geo_smk_pm_zip ~ daily_meanWS + (1 | PATIENTID), df_analysis ))
    #summary(lmer(wrf_temp_zip ~ daily_meanT + (1 | PATIENTID), df_analysis ))
    #cor(df_analysis$wrf_temp_county, df_analysis$daily_meanT)
    
    
    # populate matrix
    row_n <- j-38
    
    point_estimates[row_n, 2] <- method_list[row_n]
    point_estimates[row_n, 3] <- mod$n
    point_estimates[row_n, 4] <- mod$nevent
    # odds ratio
    point_estimates[row_n, 5] <- round(exp(summary(mod)$coefficient[1,1]), 3)
    
    # 95% lower bound
    point_estimates[row_n, 6] <- round(exp((summary(mod)$coefficient[1,1]) -
                                             1.96*(summary(mod)$coefficient[1,3])), 3)
    # 95% upper bound
    point_estimates[row_n, 7] <- round(exp((summary(mod)$coefficient[1,1]) +
                                             1.96*(summary(mod)$coefficient[1,3])), 3)
    # standard error
    point_estimates[row_n, 8] <- round(summary(mod)$coefficient[1,3], 4)
    # p val
    point_estimates[row_n, 9] <- round(summary(mod)$coefficient[1,5], 4)
    
    # save point estimates as a dataframe
    point_est_df <- as_data_frame(point_estimates)
    
  }
  
  # combine previous values in dataframe that has all outcome/methods comparisons
  datalist[[i]] <- point_est_df
  
} # end of loop

# combine each outcome dataframe itteration in to a big dataset
combined_point_est_df <- bind_rows(datalist)


# subset columns I want to put in to the table
table_df <- combined_point_est_df %>% select(2, 3:7) 



tab <- htmlTable(txtRound(table_df, digits = 3, 1:3), 
                 caption = "Association between a 10 ug/m^3 in PM2.5 and Health Outcomes",
                 # row group by outcome
                 rgroup = outcome_list,
                 n.rgroup = c(rep(3, 12)), # 4 rows for each method for each outcome
                 # column headers
                 header = c("Method", "Obs.", "Events",
                            "OR&dagger;", "Lower", "Upper"),
                 # column spanner
                 cgroup = c("", "95% CI"), 
                 n.cgroup = c(4, 2),
                 padding.rgroup = "&nbsp;&nbsp;",
                 css.cell = "padding-left: 0.5em; padding-right: .5em;", # cell space
                 align = "llccccc", # column alignment,
                 tfoot="&dagger; Adjusted for CDC temperature, relatively humidity, wind speed, and precipitation; accounting for subject. Time-stratified: referent periods matched to events on same day of week within July to October fire season."
) # end table

print(tab)

# ggplot of odds ratios, facet wrapped by outcomes -----
# convert variables from character to either numeric or factor
# factor preserves the order of the variable
combined_point_est_df$outcome <- factor(combined_point_est_df$outcome, 
                                        levels = unique(combined_point_est_df$outcome))

combined_point_est_df$pm_method <- factor(combined_point_est_df$pm_method, 
                                          levels = unique(combined_point_est_df$pm_method))

combined_point_est_df$n <- as.numeric(combined_point_est_df$n)
combined_point_est_df$n_events <- as.numeric(combined_point_est_df$n_events)
combined_point_est_df$odds_ratio <- as.numeric(combined_point_est_df$odds_ratio)
combined_point_est_df$lower95 <- as.numeric(combined_point_est_df$lower95)
combined_point_est_df$upper95 <- as.numeric(combined_point_est_df$upper95)
combined_point_est_df$se <- as.numeric(combined_point_est_df$se)
combined_point_est_df$p_val <- as.numeric(combined_point_est_df$p_val)

# subset out global method
combined_point_est_df <- combined_point_est_df


## ggplot
print_plot <- ggplot(combined_point_est_df, 
                     aes(x = pm_method, y = odds_ratio, colour = pm_method)) +
  # custom color 
  scale_color_manual(name = "Smoke-Estimation Method", 
                     values = c("red", "blue", "#32115C"),
                     guide = guide_legend(title.position = "top", title.hjust = 0.5)) +
  geom_point() + #geom_text(vjust = 0, nudge_x = 0.3) +
  geom_errorbar(aes(ymin=lower95, ymax=upper95), width = 0.2) +
  facet_wrap(~outcome, nrow = 3) +
  geom_hline(yintercept = 1, linetype=2) +
  #    ggtitle('Association Between PM2.5 \n from Wildfire Smoke on Hospitalizations') +
  ylab(expression(paste("Odds Ratio for 10Âµg/m"^3, " Increase in PM"[2.5]))) +
  #xlab('Smoke Estimation Method') +
  # plot theme
  theme(panel.background = element_rect(fill = 'white', colour = 'black'),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        # strip element
        strip.background = element_rect(colour=NA, fill=NA),
        panel.border = element_rect(fill = NA, color = "black"),
        # facet text size
        #strip.text = element_text(size = 8),
        # axis element
        axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_text(angle = 90),
        # legend elements
        legend.position = "bottom")
#legend.text = element_text(size = 8))

print(print_plot)
# save figure
ggsave("../plot_lag/fig_lag1.pdf", plot = print_plot, 
       width = 12, height = 8, units = "in")



```

```{r lag2}
df_list <- list(resp_casecross, asthma_casecross, copd_casecross, 
                pneum_casecross, acute_bronch_casecross, cvd_casecross, arrhythmia_casecross,
                cereb_vas_casecross, hf_casecross, ihd_casecross, mi_casecross, 
                broken_arm_casecross)

outcome_list <- c('All Respiratory', 'Asthma', 'COPD', 
                  'Pneumonia', 'Acute Bronchitis', 'Cardiovascular Disease',
                  'Arrhythmia', 'Cerebrovascular Disease', 'Heart Failure',
                  'Ischemic Heart Disease', 'Myocardial Infarction',
                  'Broken Arm')

method_list <- c('WRF-Chem Smoke Lag 2', 'Kriging Smoke Lag 2', 'Geo-Weighted Smoke Lag 2')

# create an empty list to row bind dataframes together
datalist <- list()

# data wrangling ----
# Producing conditional logit model estimates loop 
for(i in 1:length(df_list)){
  
  # dataframe to loop through
  df_to_loop <- data.frame(df_list[i])
  # indication of column
  outcome <- colnames(df_to_loop[76])
  # outcome name
  outcome_name <- outcome_list[i]
  
  # extract covariates from dataframe
  covariates_df <- df_to_loop[, c(1:26, 71, 74, 76:85)]
  
  # extract pm values and divide by 10 and ordered
  which(colnames(df_to_loop)=="wrf_smk_pm_lag2_zip") # 109
  which(colnames(df_to_loop)=="krig_pm_lag2_zip") # 123
  which(colnames(df_to_loop)=="geo_wt_pm_lag2_zip") # code to find column numbers, 116
  pm_estimates_df <- df_to_loop[, c(110,124,117, 94)]/10  # create 10 unit increases
  
  # dataframe for analysis creation
  # bind columns back together 
  df_analysis <- cbind(covariates_df, pm_estimates_df) %>%
    # remove missing pm values
    filter(!is.na(wrf_smk_pm_lag2_zip)) %>% 
    filter(!is.na(krig_pm_lag2_zip)) %>% 
    filter(!is.na(geo_wt_pm_lag2_zip)) %>% 
    
    # join in cdc met data
    # full_join(daily_zip_met, by = c("ZIPCODE", "date")) %>% 
    # the following code makes sure that the counterfactual values retained are 
    # symetric in that number of obs before = number of obs after
    mutate(obs_diff_admission = (fromdate - date)/7) 
  # dataframe is already for the entire fire season, so I don't need to subset anymore
  
  
  # empty df for table
  table_df <- data.frame()
  
  # empty matrix
  point_estimates <- matrix(nrow = 3, ncol = 9, byrow = T)
  
  colnames(point_estimates) <- c('outcome', 'pm_method', 'n', 'n_events', 'odds_ratio', 
                                 'lower95', 'upper95', 'se', 'p_val')
  
  # fill in the outcome name for the dataframe before the loop
  point_estimates[, 1] <- outcome_name
  
  
  # second loop to run a model for each pm estimation method
  for(j in 39:41){
    
    # variable to model 
    var_name <- colnames(df_analysis[j])
    
    # conditional logistic regression model
    mod <- clogit(outcome ~ df_analysis[[j]] + wrf_temp_zip + strata(personkey), df_analysis)
    
    # some model/DAG checks of data rish provided
    
    #glimpse(df_analysis)
    
    # adjusting for admit month is not possible as it's the same var for the subject.
    # adjusting for month smoke is a collider and should not be adjusted for.
    #summary(clogit(outcome ~ geo_smk_pm_zip + daily_meanRH + daily_meanT + daily_meanWS + daily_meanPrcp +
    #                as.factor(month_smk) + strata(PATIENTID), df_analysis))
    #outocme association: daily_meanRH, 
    
    # check for confoudning following DAG assumptions
    #summary(clogit(outcome ~ wrf_temp_zip + strata(PATIENTID), df_analysis))
    #summary(clogit(outcome ~ wrf_temp_zip + strata(PATIENTID), df_analysis))
    # smoke predictor association: daily_meanRH, 
    #summary(lmer(geo_smk_pm_zip ~ daily_meanWS + (1 | PATIENTID), df_analysis ))
    #summary(lmer(wrf_temp_zip ~ daily_meanT + (1 | PATIENTID), df_analysis ))
    #cor(df_analysis$wrf_temp_county, df_analysis$daily_meanT)
    
    
    # populate matrix
    row_n <- j-38
    
    point_estimates[row_n, 2] <- method_list[row_n]
    point_estimates[row_n, 3] <- mod$n
    point_estimates[row_n, 4] <- mod$nevent
    # odds ratio
    point_estimates[row_n, 5] <- round(exp(summary(mod)$coefficient[1,1]), 3)
    
    # 95% lower bound
    point_estimates[row_n, 6] <- round(exp((summary(mod)$coefficient[1,1]) -
                                             1.96*(summary(mod)$coefficient[1,3])), 3)
    # 95% upper bound
    point_estimates[row_n, 7] <- round(exp((summary(mod)$coefficient[1,1]) +
                                             1.96*(summary(mod)$coefficient[1,3])), 3)
    # standard error
    point_estimates[row_n, 8] <- round(summary(mod)$coefficient[1,3], 4)
    # p val
    point_estimates[row_n, 9] <- round(summary(mod)$coefficient[1,5], 4)
    
    # save point estimates as a dataframe
    point_est_df <- as_data_frame(point_estimates)
    
  }
  
  # combine previous values in dataframe that has all outcome/methods comparisons
  datalist[[i]] <- point_est_df
  
} # end of loop

# combine each outcome dataframe itteration in to a big dataset
combined_point_est_df <- bind_rows(datalist)


# subset columns I want to put in to the table
table_df <- combined_point_est_df %>% select(2, 3:7) 



tab <- htmlTable(txtRound(table_df, digits = 3, 1:3), 
                 caption = "Association between a 10 ug/m^3 in PM2.5 and Health Outcomes",
                 # row group by outcome
                 rgroup = outcome_list,
                 n.rgroup = c(rep(3, 12)), # 4 rows for each method for each outcome
                 # column headers
                 header = c("Method", "Obs.", "Events",
                            "OR&dagger;", "Lower", "Upper"),
                 # column spanner
                 cgroup = c("", "95% CI"), 
                 n.cgroup = c(4, 2),
                 padding.rgroup = "&nbsp;&nbsp;",
                 css.cell = "padding-left: 0.5em; padding-right: .5em;", # cell space
                 align = "llccccc", # column alignment,
                 tfoot="&dagger; Adjusted for CDC temperature, relatively humidity, wind speed, and precipitation; accounting for subject. Time-stratified: referent periods matched to events on same day of week within July to October fire season."
) # end table

print(tab)

# ggplot of odds ratios, facet wrapped by outcomes -----
# convert variables from character to either numeric or factor
# factor preserves the order of the variable
combined_point_est_df$outcome <- factor(combined_point_est_df$outcome, 
                                        levels = unique(combined_point_est_df$outcome))

combined_point_est_df$pm_method <- factor(combined_point_est_df$pm_method, 
                                          levels = unique(combined_point_est_df$pm_method))

combined_point_est_df$n <- as.numeric(combined_point_est_df$n)
combined_point_est_df$n_events <- as.numeric(combined_point_est_df$n_events)
combined_point_est_df$odds_ratio <- as.numeric(combined_point_est_df$odds_ratio)
combined_point_est_df$lower95 <- as.numeric(combined_point_est_df$lower95)
combined_point_est_df$upper95 <- as.numeric(combined_point_est_df$upper95)
combined_point_est_df$se <- as.numeric(combined_point_est_df$se)
combined_point_est_df$p_val <- as.numeric(combined_point_est_df$p_val)

# subset out global method
combined_point_est_df <- combined_point_est_df


## ggplot
print_plot <- ggplot(combined_point_est_df, 
                     aes(x = pm_method, y = odds_ratio, colour = pm_method)) +
  # custom color 
  scale_color_manual(name = "Smoke-Estimation Method", 
                     values = c("red", "blue", "#32115C"),
                     guide = guide_legend(title.position = "top", title.hjust = 0.5)) +
  geom_point() + #geom_text(vjust = 0, nudge_x = 0.3) +
  geom_errorbar(aes(ymin=lower95, ymax=upper95), width = 0.2) +
  facet_wrap(~outcome, nrow = 3) +
  geom_hline(yintercept = 1, linetype=2) +
  #    ggtitle('Association Between PM2.5 \n from Wildfire Smoke on Hospitalizations') +
  ylab(expression(paste("Odds Ratio for 10Âµg/m"^3, " Increase in PM"[2.5]))) +
  #xlab('Smoke Estimation Method') +
  # plot theme
  theme(panel.background = element_rect(fill = 'white', colour = 'black'),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        # strip element
        strip.background = element_rect(colour=NA, fill=NA),
        panel.border = element_rect(fill = NA, color = "black"),
        # facet text size
        #strip.text = element_text(size = 8),
        # axis element
        axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_text(angle = 90),
        # legend elements
        legend.position = "bottom")
#legend.text = element_text(size = 8))

print(print_plot)
# save figure
ggsave("../plot_lag/fig_lag2.pdf", plot = print_plot, 
       width = 12, height = 8, units = "in")



```

```{r lag3}
df_list <- list(resp_casecross, asthma_casecross, copd_casecross, 
                pneum_casecross, acute_bronch_casecross, cvd_casecross, arrhythmia_casecross,
                cereb_vas_casecross, hf_casecross, ihd_casecross, mi_casecross, 
                broken_arm_casecross)

outcome_list <- c('All Respiratory', 'Asthma', 'COPD', 
                  'Pneumonia', 'Acute Bronchitis', 'Cardiovascular Disease',
                  'Arrhythmia', 'Cerebrovascular Disease', 'Heart Failure',
                  'Ischemic Heart Disease', 'Myocardial Infarction',
                  'Broken Arm')

method_list <- c('WRF-Chem Smoke', 'Kriging Smoke', 'Geo-Weighted Smoke')

# create an empty list to row bind dataframes together
datalist <- list()

# data wrangling ----
# Producing conditional logit model estimates loop 
for(i in 1:length(df_list)){
  
  # dataframe to loop through
  df_to_loop <- data.frame(df_list[i])
  # indication of column
  outcome <- colnames(df_to_loop[76])
  # outcome name
  outcome_name <- outcome_list[i]
  
  # extract covariates from dataframe
  covariates_df <- df_to_loop[, c(1:26, 71, 74, 76:85)]
  
  # extract pm values and divide by 10 and ordered
  which(colnames(df_to_loop)=="wrf_smk_pm_lag1_zip") # 109
  which(colnames(df_to_loop)=="krig_pm_lag1_zip") # 123
  which(colnames(df_to_loop)=="geo_wt_pm_lag1_zip") # code to find column numbers, 116
  pm_estimates_df <- df_to_loop[, c(109,123,116, 94)]/10  # create 10 unit increases
  
  # dataframe for analysis creation
  # bind columns back together 
  df_analysis <- cbind(covariates_df, pm_estimates_df) %>%
    # remove missing pm values
    filter(!is.na(wrf_smk_pm_lag1_zip)) %>% 
    filter(!is.na(krig_pm_lag1_zip)) %>% 
    filter(!is.na(geo_wt_pm_lag1_zip)) %>% 
    
    # join in cdc met data
    # full_join(daily_zip_met, by = c("ZIPCODE", "date")) %>% 
    # the following code makes sure that the counterfactual values retained are 
    # symetric in that number of obs before = number of obs after
    mutate(obs_diff_admission = (fromdate - date)/7) 
  # dataframe is already for the entire fire season, so I don't need to subset anymore
  
  
  # empty df for table
  table_df <- data.frame()
  
  # empty matrix
  point_estimates <- matrix(nrow = 3, ncol = 9, byrow = T)
  
  colnames(point_estimates) <- c('outcome', 'pm_method', 'n', 'n_events', 'odds_ratio', 
                                 'lower95', 'upper95', 'se', 'p_val')
  
  # fill in the outcome name for the dataframe before the loop
  point_estimates[, 1] <- outcome_name
  
  
  # second loop to run a model for each pm estimation method
  for(j in 39:41){
    
    # variable to model 
    var_name <- colnames(df_analysis[j])
    
    # conditional logistic regression model
    mod <- clogit(outcome ~ df_analysis[[j]] + wrf_temp_zip + strata(personkey), df_analysis)
    
    # some model/DAG checks of data rish provided
    
    #glimpse(df_analysis)
    
    # adjusting for admit month is not possible as it's the same var for the subject.
    # adjusting for month smoke is a collider and should not be adjusted for.
    #summary(clogit(outcome ~ geo_smk_pm_zip + daily_meanRH + daily_meanT + daily_meanWS + daily_meanPrcp +
    #                as.factor(month_smk) + strata(PATIENTID), df_analysis))
    #outocme association: daily_meanRH, 
    
    # check for confoudning following DAG assumptions
    #summary(clogit(outcome ~ wrf_temp_zip + strata(PATIENTID), df_analysis))
    #summary(clogit(outcome ~ wrf_temp_zip + strata(PATIENTID), df_analysis))
    # smoke predictor association: daily_meanRH, 
    #summary(lmer(geo_smk_pm_zip ~ daily_meanWS + (1 | PATIENTID), df_analysis ))
    #summary(lmer(wrf_temp_zip ~ daily_meanT + (1 | PATIENTID), df_analysis ))
    #cor(df_analysis$wrf_temp_county, df_analysis$daily_meanT)
    
    
    # populate matrix
    row_n <- j-38
    
    point_estimates[row_n, 2] <- method_list[row_n]
    point_estimates[row_n, 3] <- mod$n
    point_estimates[row_n, 4] <- mod$nevent
    # odds ratio
    point_estimates[row_n, 5] <- round(exp(summary(mod)$coefficient[1,1]), 3)
    
    # 95% lower bound
    point_estimates[row_n, 6] <- round(exp((summary(mod)$coefficient[1,1]) -
                                             1.96*(summary(mod)$coefficient[1,3])), 3)
    # 95% upper bound
    point_estimates[row_n, 7] <- round(exp((summary(mod)$coefficient[1,1]) +
                                             1.96*(summary(mod)$coefficient[1,3])), 3)
    # standard error
    point_estimates[row_n, 8] <- round(summary(mod)$coefficient[1,3], 4)
    # p val
    point_estimates[row_n, 9] <- round(summary(mod)$coefficient[1,5], 4)
    
    # save point estimates as a dataframe
    point_est_df <- as_data_frame(point_estimates)
    
  }
  
  # combine previous values in dataframe that has all outcome/methods comparisons
  datalist[[i]] <- point_est_df
  
} # end of loop

# combine each outcome dataframe itteration in to a big dataset
combined_point_est_df <- bind_rows(datalist)


# subset columns I want to put in to the table
table_df <- combined_point_est_df %>% select(2, 3:7) 



tab <- htmlTable(txtRound(table_df, digits = 3, 1:3), 
                 caption = "Association between a 10 ug/m^3 in PM2.5 and Health Outcomes",
                 # row group by outcome
                 rgroup = outcome_list,
                 n.rgroup = c(rep(3, 12)), # 4 rows for each method for each outcome
                 # column headers
                 header = c("Method", "Obs.", "Events",
                            "OR&dagger;", "Lower", "Upper"),
                 # column spanner
                 cgroup = c("", "95% CI"), 
                 n.cgroup = c(4, 2),
                 padding.rgroup = "&nbsp;&nbsp;",
                 css.cell = "padding-left: 0.5em; padding-right: .5em;", # cell space
                 align = "llccccc", # column alignment,
                 tfoot="&dagger; Adjusted for CDC temperature, relatively humidity, wind speed, and precipitation; accounting for subject. Time-stratified: referent periods matched to events on same day of week within July to October fire season."
) # end table

print(tab)

# ggplot of odds ratios, facet wrapped by outcomes -----
# convert variables from character to either numeric or factor
# factor preserves the order of the variable
combined_point_est_df$outcome <- factor(combined_point_est_df$outcome, 
                                        levels = unique(combined_point_est_df$outcome))

combined_point_est_df$pm_method <- factor(combined_point_est_df$pm_method, 
                                          levels = unique(combined_point_est_df$pm_method))

combined_point_est_df$n <- as.numeric(combined_point_est_df$n)
combined_point_est_df$n_events <- as.numeric(combined_point_est_df$n_events)
combined_point_est_df$odds_ratio <- as.numeric(combined_point_est_df$odds_ratio)
combined_point_est_df$lower95 <- as.numeric(combined_point_est_df$lower95)
combined_point_est_df$upper95 <- as.numeric(combined_point_est_df$upper95)
combined_point_est_df$se <- as.numeric(combined_point_est_df$se)
combined_point_est_df$p_val <- as.numeric(combined_point_est_df$p_val)

# subset out global method
combined_point_est_df <- combined_point_est_df


## ggplot
print_plot <- ggplot(combined_point_est_df, 
                     aes(x = pm_method, y = odds_ratio, colour = pm_method)) +
  # custom color 
  scale_color_manual(name = "Smoke-Estimation Method", 
                     values = c("red", "blue", "#32115C"),
                     guide = guide_legend(title.position = "top", title.hjust = 0.5)) +
  geom_point() + #geom_text(vjust = 0, nudge_x = 0.3) +
  geom_errorbar(aes(ymin=lower95, ymax=upper95), width = 0.2) +
  facet_wrap(~outcome, nrow = 3) +
  geom_hline(yintercept = 1, linetype=2) +
  #    ggtitle('Association Between PM2.5 \n from Wildfire Smoke on Hospitalizations') +
  ylab(expression(paste("Odds Ratio for 10Âµg/m"^3, " Increase in PM"[2.5]))) +
  #xlab('Smoke Estimation Method') +
  # plot theme
  theme(panel.background = element_rect(fill = 'white', colour = 'black'),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        # strip element
        strip.background = element_rect(colour=NA, fill=NA),
        panel.border = element_rect(fill = NA, color = "black"),
        # facet text size
        #strip.text = element_text(size = 8),
        # axis element
        axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_text(angle = 90),
        # legend elements
        legend.position = "bottom")
#legend.text = element_text(size = 8))

print(print_plot)
# save figure
ggsave("../plot_lag/fig_lag1.pdf", plot = print_plot, 
       width = 12, height = 8, units = "in")



```

```{r lag4}
df_list <- list(resp_casecross, asthma_casecross, copd_casecross, 
                pneum_casecross, acute_bronch_casecross, cvd_casecross, arrhythmia_casecross,
                cereb_vas_casecross, hf_casecross, ihd_casecross, mi_casecross, 
                broken_arm_casecross)

outcome_list <- c('All Respiratory', 'Asthma', 'COPD', 
                  'Pneumonia', 'Acute Bronchitis', 'Cardiovascular Disease',
                  'Arrhythmia', 'Cerebrovascular Disease', 'Heart Failure',
                  'Ischemic Heart Disease', 'Myocardial Infarction',
                  'Broken Arm')

method_list <- c('WRF-Chem Smoke', 'Kriging Smoke', 'Geo-Weighted Smoke')

# create an empty list to row bind dataframes together
datalist <- list()

# data wrangling ----
# Producing conditional logit model estimates loop 
for(i in 1:length(df_list)){
  
  # dataframe to loop through
  df_to_loop <- data.frame(df_list[i])
  # indication of column
  outcome <- colnames(df_to_loop[76])
  # outcome name
  outcome_name <- outcome_list[i]
  
  # extract covariates from dataframe
  covariates_df <- df_to_loop[, c(1:26, 71, 74, 76:85)]
  
  # extract pm values and divide by 10 and ordered
  which(colnames(df_to_loop)=="wrf_smk_pm_lag1_zip") # 109
  which(colnames(df_to_loop)=="krig_pm_lag1_zip") # 123
  which(colnames(df_to_loop)=="geo_wt_pm_lag1_zip") # code to find column numbers, 116
  pm_estimates_df <- df_to_loop[, c(109,123,116, 94)]/10  # create 10 unit increases
  
  # dataframe for analysis creation
  # bind columns back together 
  df_analysis <- cbind(covariates_df, pm_estimates_df) %>%
    # remove missing pm values
    filter(!is.na(wrf_smk_pm_lag1_zip)) %>% 
    filter(!is.na(krig_pm_lag1_zip)) %>% 
    filter(!is.na(geo_wt_pm_lag1_zip)) %>% 
    
    # join in cdc met data
    # full_join(daily_zip_met, by = c("ZIPCODE", "date")) %>% 
    # the following code makes sure that the counterfactual values retained are 
    # symetric in that number of obs before = number of obs after
    mutate(obs_diff_admission = (fromdate - date)/7) 
  # dataframe is already for the entire fire season, so I don't need to subset anymore
  
  
  # empty df for table
  table_df <- data.frame()
  
  # empty matrix
  point_estimates <- matrix(nrow = 3, ncol = 9, byrow = T)
  
  colnames(point_estimates) <- c('outcome', 'pm_method', 'n', 'n_events', 'odds_ratio', 
                                 'lower95', 'upper95', 'se', 'p_val')
  
  # fill in the outcome name for the dataframe before the loop
  point_estimates[, 1] <- outcome_name
  
  
  # second loop to run a model for each pm estimation method
  for(j in 39:41){
    
    # variable to model 
    var_name <- colnames(df_analysis[j])
    
    # conditional logistic regression model
    mod <- clogit(outcome ~ df_analysis[[j]] + wrf_temp_zip + strata(personkey), df_analysis)
    
    # some model/DAG checks of data rish provided
    
    #glimpse(df_analysis)
    
    # adjusting for admit month is not possible as it's the same var for the subject.
    # adjusting for month smoke is a collider and should not be adjusted for.
    #summary(clogit(outcome ~ geo_smk_pm_zip + daily_meanRH + daily_meanT + daily_meanWS + daily_meanPrcp +
    #                as.factor(month_smk) + strata(PATIENTID), df_analysis))
    #outocme association: daily_meanRH, 
    
    # check for confoudning following DAG assumptions
    #summary(clogit(outcome ~ wrf_temp_zip + strata(PATIENTID), df_analysis))
    #summary(clogit(outcome ~ wrf_temp_zip + strata(PATIENTID), df_analysis))
    # smoke predictor association: daily_meanRH, 
    #summary(lmer(geo_smk_pm_zip ~ daily_meanWS + (1 | PATIENTID), df_analysis ))
    #summary(lmer(wrf_temp_zip ~ daily_meanT + (1 | PATIENTID), df_analysis ))
    #cor(df_analysis$wrf_temp_county, df_analysis$daily_meanT)
    
    
    # populate matrix
    row_n <- j-38
    
    point_estimates[row_n, 2] <- method_list[row_n]
    point_estimates[row_n, 3] <- mod$n
    point_estimates[row_n, 4] <- mod$nevent
    # odds ratio
    point_estimates[row_n, 5] <- round(exp(summary(mod)$coefficient[1,1]), 3)
    
    # 95% lower bound
    point_estimates[row_n, 6] <- round(exp((summary(mod)$coefficient[1,1]) -
                                             1.96*(summary(mod)$coefficient[1,3])), 3)
    # 95% upper bound
    point_estimates[row_n, 7] <- round(exp((summary(mod)$coefficient[1,1]) +
                                             1.96*(summary(mod)$coefficient[1,3])), 3)
    # standard error
    point_estimates[row_n, 8] <- round(summary(mod)$coefficient[1,3], 4)
    # p val
    point_estimates[row_n, 9] <- round(summary(mod)$coefficient[1,5], 4)
    
    # save point estimates as a dataframe
    point_est_df <- as_data_frame(point_estimates)
    
  }
  
  # combine previous values in dataframe that has all outcome/methods comparisons
  datalist[[i]] <- point_est_df
  
} # end of loop

# combine each outcome dataframe itteration in to a big dataset
combined_point_est_df <- bind_rows(datalist)


# subset columns I want to put in to the table
table_df <- combined_point_est_df %>% select(2, 3:7) 



tab <- htmlTable(txtRound(table_df, digits = 3, 1:3), 
                 caption = "Association between a 10 ug/m^3 in PM2.5 and Health Outcomes",
                 # row group by outcome
                 rgroup = outcome_list,
                 n.rgroup = c(rep(3, 12)), # 4 rows for each method for each outcome
                 # column headers
                 header = c("Method", "Obs.", "Events",
                            "OR&dagger;", "Lower", "Upper"),
                 # column spanner
                 cgroup = c("", "95% CI"), 
                 n.cgroup = c(4, 2),
                 padding.rgroup = "&nbsp;&nbsp;",
                 css.cell = "padding-left: 0.5em; padding-right: .5em;", # cell space
                 align = "llccccc", # column alignment,
                 tfoot="&dagger; Adjusted for CDC temperature, relatively humidity, wind speed, and precipitation; accounting for subject. Time-stratified: referent periods matched to events on same day of week within July to October fire season."
) # end table

print(tab)

# ggplot of odds ratios, facet wrapped by outcomes -----
# convert variables from character to either numeric or factor
# factor preserves the order of the variable
combined_point_est_df$outcome <- factor(combined_point_est_df$outcome, 
                                        levels = unique(combined_point_est_df$outcome))

combined_point_est_df$pm_method <- factor(combined_point_est_df$pm_method, 
                                          levels = unique(combined_point_est_df$pm_method))

combined_point_est_df$n <- as.numeric(combined_point_est_df$n)
combined_point_est_df$n_events <- as.numeric(combined_point_est_df$n_events)
combined_point_est_df$odds_ratio <- as.numeric(combined_point_est_df$odds_ratio)
combined_point_est_df$lower95 <- as.numeric(combined_point_est_df$lower95)
combined_point_est_df$upper95 <- as.numeric(combined_point_est_df$upper95)
combined_point_est_df$se <- as.numeric(combined_point_est_df$se)
combined_point_est_df$p_val <- as.numeric(combined_point_est_df$p_val)

# subset out global method
combined_point_est_df <- combined_point_est_df


## ggplot
print_plot <- ggplot(combined_point_est_df, 
                     aes(x = pm_method, y = odds_ratio, colour = pm_method)) +
  # custom color 
  scale_color_manual(name = "Smoke-Estimation Method", 
                     values = c("red", "blue", "#32115C"),
                     guide = guide_legend(title.position = "top", title.hjust = 0.5)) +
  geom_point() + #geom_text(vjust = 0, nudge_x = 0.3) +
  geom_errorbar(aes(ymin=lower95, ymax=upper95), width = 0.2) +
  facet_wrap(~outcome, nrow = 3) +
  geom_hline(yintercept = 1, linetype=2) +
  #    ggtitle('Association Between PM2.5 \n from Wildfire Smoke on Hospitalizations') +
  ylab(expression(paste("Odds Ratio for 10Âµg/m"^3, " Increase in PM"[2.5]))) +
  #xlab('Smoke Estimation Method') +
  # plot theme
  theme(panel.background = element_rect(fill = 'white', colour = 'black'),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        # strip element
        strip.background = element_rect(colour=NA, fill=NA),
        panel.border = element_rect(fill = NA, color = "black"),
        # facet text size
        #strip.text = element_text(size = 8),
        # axis element
        axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_text(angle = 90),
        # legend elements
        legend.position = "bottom")
#legend.text = element_text(size = 8))

print(print_plot)
# save figure
ggsave("../plot_lag/fig_lag1.pdf", plot = print_plot, 
       width = 12, height = 8, units = "in")



```

```{r lag5}
df_list <- list(resp_casecross, asthma_casecross, copd_casecross, 
                pneum_casecross, acute_bronch_casecross, cvd_casecross, arrhythmia_casecross,
                cereb_vas_casecross, hf_casecross, ihd_casecross, mi_casecross, 
                broken_arm_casecross)

outcome_list <- c('All Respiratory', 'Asthma', 'COPD', 
                  'Pneumonia', 'Acute Bronchitis', 'Cardiovascular Disease',
                  'Arrhythmia', 'Cerebrovascular Disease', 'Heart Failure',
                  'Ischemic Heart Disease', 'Myocardial Infarction',
                  'Broken Arm')

method_list <- c('WRF-Chem Smoke', 'Kriging Smoke', 'Geo-Weighted Smoke')

# create an empty list to row bind dataframes together
datalist <- list()

# data wrangling ----
# Producing conditional logit model estimates loop 
for(i in 1:length(df_list)){
  
  # dataframe to loop through
  df_to_loop <- data.frame(df_list[i])
  # indication of column
  outcome <- colnames(df_to_loop[76])
  # outcome name
  outcome_name <- outcome_list[i]
  
  # extract covariates from dataframe
  covariates_df <- df_to_loop[, c(1:26, 71, 74, 76:85)]
  
  # extract pm values and divide by 10 and ordered
  which(colnames(df_to_loop)=="wrf_smk_pm_lag1_zip") # 109
  which(colnames(df_to_loop)=="krig_pm_lag1_zip") # 123
  which(colnames(df_to_loop)=="geo_wt_pm_lag1_zip") # code to find column numbers, 116
  pm_estimates_df <- df_to_loop[, c(109,123,116, 94)]/10  # create 10 unit increases
  
  # dataframe for analysis creation
  # bind columns back together 
  df_analysis <- cbind(covariates_df, pm_estimates_df) %>%
    # remove missing pm values
    filter(!is.na(wrf_smk_pm_lag1_zip)) %>% 
    filter(!is.na(krig_pm_lag1_zip)) %>% 
    filter(!is.na(geo_wt_pm_lag1_zip)) %>% 
    
    # join in cdc met data
    # full_join(daily_zip_met, by = c("ZIPCODE", "date")) %>% 
    # the following code makes sure that the counterfactual values retained are 
    # symetric in that number of obs before = number of obs after
    mutate(obs_diff_admission = (fromdate - date)/7) 
  # dataframe is already for the entire fire season, so I don't need to subset anymore
  
  
  # empty df for table
  table_df <- data.frame()
  
  # empty matrix
  point_estimates <- matrix(nrow = 3, ncol = 9, byrow = T)
  
  colnames(point_estimates) <- c('outcome', 'pm_method', 'n', 'n_events', 'odds_ratio', 
                                 'lower95', 'upper95', 'se', 'p_val')
  
  # fill in the outcome name for the dataframe before the loop
  point_estimates[, 1] <- outcome_name
  
  
  # second loop to run a model for each pm estimation method
  for(j in 39:41){
    
    # variable to model 
    var_name <- colnames(df_analysis[j])
    
    # conditional logistic regression model
    mod <- clogit(outcome ~ df_analysis[[j]] + wrf_temp_zip + strata(personkey), df_analysis)
    
    # some model/DAG checks of data rish provided
    
    #glimpse(df_analysis)
    
    # adjusting for admit month is not possible as it's the same var for the subject.
    # adjusting for month smoke is a collider and should not be adjusted for.
    #summary(clogit(outcome ~ geo_smk_pm_zip + daily_meanRH + daily_meanT + daily_meanWS + daily_meanPrcp +
    #                as.factor(month_smk) + strata(PATIENTID), df_analysis))
    #outocme association: daily_meanRH, 
    
    # check for confoudning following DAG assumptions
    #summary(clogit(outcome ~ wrf_temp_zip + strata(PATIENTID), df_analysis))
    #summary(clogit(outcome ~ wrf_temp_zip + strata(PATIENTID), df_analysis))
    # smoke predictor association: daily_meanRH, 
    #summary(lmer(geo_smk_pm_zip ~ daily_meanWS + (1 | PATIENTID), df_analysis ))
    #summary(lmer(wrf_temp_zip ~ daily_meanT + (1 | PATIENTID), df_analysis ))
    #cor(df_analysis$wrf_temp_county, df_analysis$daily_meanT)
    
    
    # populate matrix
    row_n <- j-38
    
    point_estimates[row_n, 2] <- method_list[row_n]
    point_estimates[row_n, 3] <- mod$n
    point_estimates[row_n, 4] <- mod$nevent
    # odds ratio
    point_estimates[row_n, 5] <- round(exp(summary(mod)$coefficient[1,1]), 3)
    
    # 95% lower bound
    point_estimates[row_n, 6] <- round(exp((summary(mod)$coefficient[1,1]) -
                                             1.96*(summary(mod)$coefficient[1,3])), 3)
    # 95% upper bound
    point_estimates[row_n, 7] <- round(exp((summary(mod)$coefficient[1,1]) +
                                             1.96*(summary(mod)$coefficient[1,3])), 3)
    # standard error
    point_estimates[row_n, 8] <- round(summary(mod)$coefficient[1,3], 4)
    # p val
    point_estimates[row_n, 9] <- round(summary(mod)$coefficient[1,5], 4)
    
    # save point estimates as a dataframe
    point_est_df <- as_data_frame(point_estimates)
    
  }
  
  # combine previous values in dataframe that has all outcome/methods comparisons
  datalist[[i]] <- point_est_df
  
} # end of loop

# combine each outcome dataframe itteration in to a big dataset
combined_point_est_df <- bind_rows(datalist)


# subset columns I want to put in to the table
table_df <- combined_point_est_df %>% select(2, 3:7) 



tab <- htmlTable(txtRound(table_df, digits = 3, 1:3), 
                 caption = "Association between a 10 ug/m^3 in PM2.5 and Health Outcomes",
                 # row group by outcome
                 rgroup = outcome_list,
                 n.rgroup = c(rep(3, 12)), # 4 rows for each method for each outcome
                 # column headers
                 header = c("Method", "Obs.", "Events",
                            "OR&dagger;", "Lower", "Upper"),
                 # column spanner
                 cgroup = c("", "95% CI"), 
                 n.cgroup = c(4, 2),
                 padding.rgroup = "&nbsp;&nbsp;",
                 css.cell = "padding-left: 0.5em; padding-right: .5em;", # cell space
                 align = "llccccc", # column alignment,
                 tfoot="&dagger; Adjusted for CDC temperature, relatively humidity, wind speed, and precipitation; accounting for subject. Time-stratified: referent periods matched to events on same day of week within July to October fire season."
) # end table

print(tab)

# ggplot of odds ratios, facet wrapped by outcomes -----
# convert variables from character to either numeric or factor
# factor preserves the order of the variable
combined_point_est_df$outcome <- factor(combined_point_est_df$outcome, 
                                        levels = unique(combined_point_est_df$outcome))

combined_point_est_df$pm_method <- factor(combined_point_est_df$pm_method, 
                                          levels = unique(combined_point_est_df$pm_method))

combined_point_est_df$n <- as.numeric(combined_point_est_df$n)
combined_point_est_df$n_events <- as.numeric(combined_point_est_df$n_events)
combined_point_est_df$odds_ratio <- as.numeric(combined_point_est_df$odds_ratio)
combined_point_est_df$lower95 <- as.numeric(combined_point_est_df$lower95)
combined_point_est_df$upper95 <- as.numeric(combined_point_est_df$upper95)
combined_point_est_df$se <- as.numeric(combined_point_est_df$se)
combined_point_est_df$p_val <- as.numeric(combined_point_est_df$p_val)

# subset out global method
combined_point_est_df <- combined_point_est_df


## ggplot
print_plot <- ggplot(combined_point_est_df, 
                     aes(x = pm_method, y = odds_ratio, colour = pm_method)) +
  # custom color 
  scale_color_manual(name = "Smoke-Estimation Method", 
                     values = c("red", "blue", "#32115C"),
                     guide = guide_legend(title.position = "top", title.hjust = 0.5)) +
  geom_point() + #geom_text(vjust = 0, nudge_x = 0.3) +
  geom_errorbar(aes(ymin=lower95, ymax=upper95), width = 0.2) +
  facet_wrap(~outcome, nrow = 3) +
  geom_hline(yintercept = 1, linetype=2) +
  #    ggtitle('Association Between PM2.5 \n from Wildfire Smoke on Hospitalizations') +
  ylab(expression(paste("Odds Ratio for 10Âµg/m"^3, " Increase in PM"[2.5]))) +
  #xlab('Smoke Estimation Method') +
  # plot theme
  theme(panel.background = element_rect(fill = 'white', colour = 'black'),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        # strip element
        strip.background = element_rect(colour=NA, fill=NA),
        panel.border = element_rect(fill = NA, color = "black"),
        # facet text size
        #strip.text = element_text(size = 8),
        # axis element
        axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_text(angle = 90),
        # legend elements
        legend.position = "bottom")
#legend.text = element_text(size = 8))

print(print_plot)
# save figure
ggsave("../plot_lag/fig_lag1.pdf", plot = print_plot, 
       width = 12, height = 8, units = "in")



```

```{r lag6}
df_list <- list(resp_casecross, asthma_casecross, copd_casecross, 
                pneum_casecross, acute_bronch_casecross, cvd_casecross, arrhythmia_casecross,
                cereb_vas_casecross, hf_casecross, ihd_casecross, mi_casecross, 
                broken_arm_casecross)

outcome_list <- c('All Respiratory', 'Asthma', 'COPD', 
                  'Pneumonia', 'Acute Bronchitis', 'Cardiovascular Disease',
                  'Arrhythmia', 'Cerebrovascular Disease', 'Heart Failure',
                  'Ischemic Heart Disease', 'Myocardial Infarction',
                  'Broken Arm')

method_list <- c('WRF-Chem Smoke', 'Kriging Smoke', 'Geo-Weighted Smoke')

# create an empty list to row bind dataframes together
datalist <- list()

# data wrangling ----
# Producing conditional logit model estimates loop 
for(i in 1:length(df_list)){
  
  # dataframe to loop through
  df_to_loop <- data.frame(df_list[i])
  # indication of column
  outcome <- colnames(df_to_loop[76])
  # outcome name
  outcome_name <- outcome_list[i]
  
  # extract covariates from dataframe
  covariates_df <- df_to_loop[, c(1:26, 71, 74, 76:85)]
  
  # extract pm values and divide by 10 and ordered
  which(colnames(df_to_loop)=="wrf_smk_pm_lag1_zip") # 109
  which(colnames(df_to_loop)=="krig_pm_lag1_zip") # 123
  which(colnames(df_to_loop)=="geo_wt_pm_lag1_zip") # code to find column numbers, 116
  pm_estimates_df <- df_to_loop[, c(109,123,116, 94)]/10  # create 10 unit increases
  
  # dataframe for analysis creation
  # bind columns back together 
  df_analysis <- cbind(covariates_df, pm_estimates_df) %>%
    # remove missing pm values
    filter(!is.na(wrf_smk_pm_lag1_zip)) %>% 
    filter(!is.na(krig_pm_lag1_zip)) %>% 
    filter(!is.na(geo_wt_pm_lag1_zip)) %>% 
    
    # join in cdc met data
    # full_join(daily_zip_met, by = c("ZIPCODE", "date")) %>% 
    # the following code makes sure that the counterfactual values retained are 
    # symetric in that number of obs before = number of obs after
    mutate(obs_diff_admission = (fromdate - date)/7) 
  # dataframe is already for the entire fire season, so I don't need to subset anymore
  
  
  # empty df for table
  table_df <- data.frame()
  
  # empty matrix
  point_estimates <- matrix(nrow = 3, ncol = 9, byrow = T)
  
  colnames(point_estimates) <- c('outcome', 'pm_method', 'n', 'n_events', 'odds_ratio', 
                                 'lower95', 'upper95', 'se', 'p_val')
  
  # fill in the outcome name for the dataframe before the loop
  point_estimates[, 1] <- outcome_name
  
  
  # second loop to run a model for each pm estimation method
  for(j in 39:41){
    
    # variable to model 
    var_name <- colnames(df_analysis[j])
    
    # conditional logistic regression model
    mod <- clogit(outcome ~ df_analysis[[j]] + wrf_temp_zip + strata(personkey), df_analysis)
    
    # some model/DAG checks of data rish provided
    
    #glimpse(df_analysis)
    
    # adjusting for admit month is not possible as it's the same var for the subject.
    # adjusting for month smoke is a collider and should not be adjusted for.
    #summary(clogit(outcome ~ geo_smk_pm_zip + daily_meanRH + daily_meanT + daily_meanWS + daily_meanPrcp +
    #                as.factor(month_smk) + strata(PATIENTID), df_analysis))
    #outocme association: daily_meanRH, 
    
    # check for confoudning following DAG assumptions
    #summary(clogit(outcome ~ wrf_temp_zip + strata(PATIENTID), df_analysis))
    #summary(clogit(outcome ~ wrf_temp_zip + strata(PATIENTID), df_analysis))
    # smoke predictor association: daily_meanRH, 
    #summary(lmer(geo_smk_pm_zip ~ daily_meanWS + (1 | PATIENTID), df_analysis ))
    #summary(lmer(wrf_temp_zip ~ daily_meanT + (1 | PATIENTID), df_analysis ))
    #cor(df_analysis$wrf_temp_county, df_analysis$daily_meanT)
    
    
    # populate matrix
    row_n <- j-38
    
    point_estimates[row_n, 2] <- method_list[row_n]
    point_estimates[row_n, 3] <- mod$n
    point_estimates[row_n, 4] <- mod$nevent
    # odds ratio
    point_estimates[row_n, 5] <- round(exp(summary(mod)$coefficient[1,1]), 3)
    
    # 95% lower bound
    point_estimates[row_n, 6] <- round(exp((summary(mod)$coefficient[1,1]) -
                                             1.96*(summary(mod)$coefficient[1,3])), 3)
    # 95% upper bound
    point_estimates[row_n, 7] <- round(exp((summary(mod)$coefficient[1,1]) +
                                             1.96*(summary(mod)$coefficient[1,3])), 3)
    # standard error
    point_estimates[row_n, 8] <- round(summary(mod)$coefficient[1,3], 4)
    # p val
    point_estimates[row_n, 9] <- round(summary(mod)$coefficient[1,5], 4)
    
    # save point estimates as a dataframe
    point_est_df <- as_data_frame(point_estimates)
    
  }
  
  # combine previous values in dataframe that has all outcome/methods comparisons
  datalist[[i]] <- point_est_df
  
} # end of loop

# combine each outcome dataframe itteration in to a big dataset
combined_point_est_df <- bind_rows(datalist)


# subset columns I want to put in to the table
table_df <- combined_point_est_df %>% select(2, 3:7) 



tab <- htmlTable(txtRound(table_df, digits = 3, 1:3), 
                 caption = "Association between a 10 ug/m^3 in PM2.5 and Health Outcomes",
                 # row group by outcome
                 rgroup = outcome_list,
                 n.rgroup = c(rep(3, 12)), # 4 rows for each method for each outcome
                 # column headers
                 header = c("Method", "Obs.", "Events",
                            "OR&dagger;", "Lower", "Upper"),
                 # column spanner
                 cgroup = c("", "95% CI"), 
                 n.cgroup = c(4, 2),
                 padding.rgroup = "&nbsp;&nbsp;",
                 css.cell = "padding-left: 0.5em; padding-right: .5em;", # cell space
                 align = "llccccc", # column alignment,
                 tfoot="&dagger; Adjusted for CDC temperature, relatively humidity, wind speed, and precipitation; accounting for subject. Time-stratified: referent periods matched to events on same day of week within July to October fire season."
) # end table

print(tab)

# ggplot of odds ratios, facet wrapped by outcomes -----
# convert variables from character to either numeric or factor
# factor preserves the order of the variable
combined_point_est_df$outcome <- factor(combined_point_est_df$outcome, 
                                        levels = unique(combined_point_est_df$outcome))

combined_point_est_df$pm_method <- factor(combined_point_est_df$pm_method, 
                                          levels = unique(combined_point_est_df$pm_method))

combined_point_est_df$n <- as.numeric(combined_point_est_df$n)
combined_point_est_df$n_events <- as.numeric(combined_point_est_df$n_events)
combined_point_est_df$odds_ratio <- as.numeric(combined_point_est_df$odds_ratio)
combined_point_est_df$lower95 <- as.numeric(combined_point_est_df$lower95)
combined_point_est_df$upper95 <- as.numeric(combined_point_est_df$upper95)
combined_point_est_df$se <- as.numeric(combined_point_est_df$se)
combined_point_est_df$p_val <- as.numeric(combined_point_est_df$p_val)

# subset out global method
combined_point_est_df <- combined_point_est_df


## ggplot
print_plot <- ggplot(combined_point_est_df, 
                     aes(x = pm_method, y = odds_ratio, colour = pm_method)) +
  # custom color 
  scale_color_manual(name = "Smoke-Estimation Method", 
                     values = c("red", "blue", "#32115C"),
                     guide = guide_legend(title.position = "top", title.hjust = 0.5)) +
  geom_point() + #geom_text(vjust = 0, nudge_x = 0.3) +
  geom_errorbar(aes(ymin=lower95, ymax=upper95), width = 0.2) +
  facet_wrap(~outcome, nrow = 3) +
  geom_hline(yintercept = 1, linetype=2) +
  #    ggtitle('Association Between PM2.5 \n from Wildfire Smoke on Hospitalizations') +
  ylab(expression(paste("Odds Ratio for 10Âµg/m"^3, " Increase in PM"[2.5]))) +
  #xlab('Smoke Estimation Method') +
  # plot theme
  theme(panel.background = element_rect(fill = 'white', colour = 'black'),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        # strip element
        strip.background = element_rect(colour=NA, fill=NA),
        panel.border = element_rect(fill = NA, color = "black"),
        # facet text size
        #strip.text = element_text(size = 8),
        # axis element
        axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_text(angle = 90),
        # legend elements
        legend.position = "bottom")
#legend.text = element_text(size = 8))

print(print_plot)
# save figure
ggsave("../plot_lag/fig_lag1.pdf", plot = print_plot, 
       width = 12, height = 8, units = "in")



```

```{r lag7}
df_list <- list(resp_casecross, asthma_casecross, copd_casecross, 
                pneum_casecross, acute_bronch_casecross, cvd_casecross, arrhythmia_casecross,
                cereb_vas_casecross, hf_casecross, ihd_casecross, mi_casecross, 
                broken_arm_casecross)

outcome_list <- c('All Respiratory', 'Asthma', 'COPD', 
                  'Pneumonia', 'Acute Bronchitis', 'Cardiovascular Disease',
                  'Arrhythmia', 'Cerebrovascular Disease', 'Heart Failure',
                  'Ischemic Heart Disease', 'Myocardial Infarction',
                  'Broken Arm')

method_list <- c('WRF-Chem Smoke', 'Kriging Smoke', 'Geo-Weighted Smoke')

# create an empty list to row bind dataframes together
datalist <- list()

# data wrangling ----
# Producing conditional logit model estimates loop 
for(i in 1:length(df_list)){
  
  # dataframe to loop through
  df_to_loop <- data.frame(df_list[i])
  # indication of column
  outcome <- colnames(df_to_loop[76])
  # outcome name
  outcome_name <- outcome_list[i]
  
  # extract covariates from dataframe
  covariates_df <- df_to_loop[, c(1:26, 71, 74, 76:85)]
  
  # extract pm values and divide by 10 and ordered
  which(colnames(df_to_loop)=="wrf_smk_pm_lag1_zip") # 109
  which(colnames(df_to_loop)=="krig_pm_lag1_zip") # 123
  which(colnames(df_to_loop)=="geo_wt_pm_lag1_zip") # code to find column numbers, 116
  pm_estimates_df <- df_to_loop[, c(109,123,116, 94)]/10  # create 10 unit increases
  
  # dataframe for analysis creation
  # bind columns back together 
  df_analysis <- cbind(covariates_df, pm_estimates_df) %>%
    # remove missing pm values
    filter(!is.na(wrf_smk_pm_lag1_zip)) %>% 
    filter(!is.na(krig_pm_lag1_zip)) %>% 
    filter(!is.na(geo_wt_pm_lag1_zip)) %>% 
    
    # join in cdc met data
    # full_join(daily_zip_met, by = c("ZIPCODE", "date")) %>% 
    # the following code makes sure that the counterfactual values retained are 
    # symetric in that number of obs before = number of obs after
    mutate(obs_diff_admission = (fromdate - date)/7) 
  # dataframe is already for the entire fire season, so I don't need to subset anymore
  
  
  # empty df for table
  table_df <- data.frame()
  
  # empty matrix
  point_estimates <- matrix(nrow = 3, ncol = 9, byrow = T)
  
  colnames(point_estimates) <- c('outcome', 'pm_method', 'n', 'n_events', 'odds_ratio', 
                                 'lower95', 'upper95', 'se', 'p_val')
  
  # fill in the outcome name for the dataframe before the loop
  point_estimates[, 1] <- outcome_name
  
  
  # second loop to run a model for each pm estimation method
  for(j in 39:41){
    
    # variable to model 
    var_name <- colnames(df_analysis[j])
    
    # conditional logistic regression model
    mod <- clogit(outcome ~ df_analysis[[j]] + wrf_temp_zip + strata(personkey), df_analysis)
    
    # some model/DAG checks of data rish provided
    
    #glimpse(df_analysis)
    
    # adjusting for admit month is not possible as it's the same var for the subject.
    # adjusting for month smoke is a collider and should not be adjusted for.
    #summary(clogit(outcome ~ geo_smk_pm_zip + daily_meanRH + daily_meanT + daily_meanWS + daily_meanPrcp +
    #                as.factor(month_smk) + strata(PATIENTID), df_analysis))
    #outocme association: daily_meanRH, 
    
    # check for confoudning following DAG assumptions
    #summary(clogit(outcome ~ wrf_temp_zip + strata(PATIENTID), df_analysis))
    #summary(clogit(outcome ~ wrf_temp_zip + strata(PATIENTID), df_analysis))
    # smoke predictor association: daily_meanRH, 
    #summary(lmer(geo_smk_pm_zip ~ daily_meanWS + (1 | PATIENTID), df_analysis ))
    #summary(lmer(wrf_temp_zip ~ daily_meanT + (1 | PATIENTID), df_analysis ))
    #cor(df_analysis$wrf_temp_county, df_analysis$daily_meanT)
    
    
    # populate matrix
    row_n <- j-38
    
    point_estimates[row_n, 2] <- method_list[row_n]
    point_estimates[row_n, 3] <- mod$n
    point_estimates[row_n, 4] <- mod$nevent
    # odds ratio
    point_estimates[row_n, 5] <- round(exp(summary(mod)$coefficient[1,1]), 3)
    
    # 95% lower bound
    point_estimates[row_n, 6] <- round(exp((summary(mod)$coefficient[1,1]) -
                                             1.96*(summary(mod)$coefficient[1,3])), 3)
    # 95% upper bound
    point_estimates[row_n, 7] <- round(exp((summary(mod)$coefficient[1,1]) +
                                             1.96*(summary(mod)$coefficient[1,3])), 3)
    # standard error
    point_estimates[row_n, 8] <- round(summary(mod)$coefficient[1,3], 4)
    # p val
    point_estimates[row_n, 9] <- round(summary(mod)$coefficient[1,5], 4)
    
    # save point estimates as a dataframe
    point_est_df <- as_data_frame(point_estimates)
    
  }
  
  # combine previous values in dataframe that has all outcome/methods comparisons
  datalist[[i]] <- point_est_df
  
} # end of loop

# combine each outcome dataframe itteration in to a big dataset
combined_point_est_df <- bind_rows(datalist)


# subset columns I want to put in to the table
table_df <- combined_point_est_df %>% select(2, 3:7) 



tab <- htmlTable(txtRound(table_df, digits = 3, 1:3), 
                 caption = "Association between a 10 ug/m^3 in PM2.5 and Health Outcomes",
                 # row group by outcome
                 rgroup = outcome_list,
                 n.rgroup = c(rep(3, 12)), # 4 rows for each method for each outcome
                 # column headers
                 header = c("Method", "Obs.", "Events",
                            "OR&dagger;", "Lower", "Upper"),
                 # column spanner
                 cgroup = c("", "95% CI"), 
                 n.cgroup = c(4, 2),
                 padding.rgroup = "&nbsp;&nbsp;",
                 css.cell = "padding-left: 0.5em; padding-right: .5em;", # cell space
                 align = "llccccc", # column alignment,
                 tfoot="&dagger; Adjusted for CDC temperature, relatively humidity, wind speed, and precipitation; accounting for subject. Time-stratified: referent periods matched to events on same day of week within July to October fire season."
) # end table

print(tab)

# ggplot of odds ratios, facet wrapped by outcomes -----
# convert variables from character to either numeric or factor
# factor preserves the order of the variable
combined_point_est_df$outcome <- factor(combined_point_est_df$outcome, 
                                        levels = unique(combined_point_est_df$outcome))

combined_point_est_df$pm_method <- factor(combined_point_est_df$pm_method, 
                                          levels = unique(combined_point_est_df$pm_method))

combined_point_est_df$n <- as.numeric(combined_point_est_df$n)
combined_point_est_df$n_events <- as.numeric(combined_point_est_df$n_events)
combined_point_est_df$odds_ratio <- as.numeric(combined_point_est_df$odds_ratio)
combined_point_est_df$lower95 <- as.numeric(combined_point_est_df$lower95)
combined_point_est_df$upper95 <- as.numeric(combined_point_est_df$upper95)
combined_point_est_df$se <- as.numeric(combined_point_est_df$se)
combined_point_est_df$p_val <- as.numeric(combined_point_est_df$p_val)

# subset out global method
combined_point_est_df <- combined_point_est_df


## ggplot
print_plot <- ggplot(combined_point_est_df, 
                     aes(x = pm_method, y = odds_ratio, colour = pm_method)) +
  # custom color 
  scale_color_manual(name = "Smoke-Estimation Method", 
                     values = c("red", "blue", "#32115C"),
                     guide = guide_legend(title.position = "top", title.hjust = 0.5)) +
  geom_point() + #geom_text(vjust = 0, nudge_x = 0.3) +
  geom_errorbar(aes(ymin=lower95, ymax=upper95), width = 0.2) +
  facet_wrap(~outcome, nrow = 3) +
  geom_hline(yintercept = 1, linetype=2) +
  #    ggtitle('Association Between PM2.5 \n from Wildfire Smoke on Hospitalizations') +
  ylab(expression(paste("Odds Ratio for 10Âµg/m"^3, " Increase in PM"[2.5]))) +
  #xlab('Smoke Estimation Method') +
  # plot theme
  theme(panel.background = element_rect(fill = 'white', colour = 'black'),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        # strip element
        strip.background = element_rect(colour=NA, fill=NA),
        panel.border = element_rect(fill = NA, color = "black"),
        # facet text size
        #strip.text = element_text(size = 8),
        # axis element
        axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_text(angle = 90),
        # legend elements
        legend.position = "bottom")
#legend.text = element_text(size = 8))

print(print_plot)
# save figure
ggsave("../plot_lag/fig_lag1.pdf", plot = print_plot, 
       width = 12, height = 8, units = "in")



```





