---
title: Distributed lag effects of smoke on cardiovascular disease in persons over 65
author: "Ryan Gan"
date: "2017-11-20"
output: html_document
---

## Overview

Extensive look at possible distributed lag relationships for Cardiovascular endpoints in the over 65 age group.

Packages used: tidyverse, survival. Setting markdown options.

```{r setup, echo =F, warning=F, message=F}
library(tidyverse) # general data wrangle
library(survival) # conditional logistic regression

# knitr options
knitr::opts_chunk$set(fig.width=8, fig.height=6, fig.path='Figs/',
                      echo=FALSE, warning=FALSE, message=FALSE)
```

Importing the time-stratified case-crossover dataframes for the cardiovascular endpoints.

```{r health data import}
# path for health dataframe
health_path <- "../../data/health/"
# importing time-stratified case-crossover dataframe
casecross_files <- list.files(path=health_path, pattern="*casecross*")

# reorder file names in way I'd like it to be analyzed and only importing cvd
# also ditching broken arm
casecross_order <- casecross_files[c(7,2,5,8,9,10)]

# extract the name of the dataframe after study type
file_names <- stringr::str_extract(casecross_order, 
  pattern="(?<=casecross_)\\w+")

# read in all the files in to a list
cvd_over65_list <- casecross_order %>%  
  purrr::map(~read_csv(paste0(health_path, .))) %>% 
  # filter to over 65 group
  purrr::map(~filter(., age >= 65)) 

# name dataframes
names(cvd_over65_list) <- file_names

# name list elements in order I'd like to present in document
outcome_names <- c("Cardiovascular Disease", "Arrhythmia", 
  "Cerebrovascular Disease", "Heart Failure", "Ischemic Heart Disease", 
  "Myocardial Infarction")
```

Creating a fit function to find the degrees of freedom for the pm spline

```{r custom distributed lag fit function}
# fit function
dl_fit <- function(data, pm_df, temp_df){
  # i want to remove this part eventually ------
  # limit to complete cases
  complete_data <- data %>% 
    # filter to complete case for smoke
    filter(!is.na(geo_smk_pm_lag7_zip))

  # output matrix of gwr values
  pm_matrix <- complete_data %>% 
    select(contains("geo_smk_pm")) %>%
    # remove anything with m in it; will go back in original code and not create 
    # this to begin with
    select(-contains("_m")) %>% 
    # divide exposure values by 10 units to interpret on 10 ug/m^3 scale
    mutate_all(funs(./10)) %>% 
    # convert to matrix
    as.matrix()
  
  # output temp matrix
  temp_matrix <- complete_data %>% 
    select(contains("wrf_temp")) %>%
    # remove anything with m in it; will go back in original code and not create 
    # this to begin with
    select(-contains("_m")) %>% 
    # convert to matrix
    as.matrix()
  # end part to remove------
  
    # create temp basis
    temp_b <- splines::ns(0:(ncol(temp_matrix)-1), df=temp_df, intercept=T)
    temp_basis <- temp_matrix %*% temp_b
    
      # create list of lengh pm_df
      mod_aic <- sapply(pm_df, function(x){
        pm_b <- splines::ns(0:(ncol(pm_matrix)-1), df=x, intercept=T)
        # create pm basis
        pm_basis <- pm_matrix %*% pm_b
        # run model
        mod <- clogit(outcome ~ pm_basis + temp_basis + strata(personkey),
          data = complete_data)
        aic <- AIC(mod)
        return(aic)
      }) # end sapply

    # find minimum aic
    pm_df_aic <- data.frame(pm_df, mod_aic)
    min_df_aic <- subset(pm_df_aic, mod_aic == min(mod_aic))
    return(min_df_aic)
  } # end fit option
```


```{r custom distributed lag function}
# custom distributed lag function 
distributed_lag <- function(data, pm_df, temp_df, cumulative=T){
  # i want to remove this part eventually ------
  # limit to complete cases
  complete_data <- data %>% 
    # filter to complete case for smoke
    filter(!is.na(geo_smk_pm_lag7_zip))

  # output matrix of gwr values
  pm_matrix <- complete_data %>% 
    select(contains("geo_smk_pm")) %>%
    # remove anything with m in it; will go back in original code and not create 
    # this to begin with
    select(-contains("_m")) %>% 
    # divide exposure values by 10 units to interpret on 10 ug/m^3 scale
    mutate_all(funs(./10)) %>% 
    # convert to matrix
    as.matrix()
  
  # output temp matrix
  temp_matrix <- complete_data %>% 
    select(contains("wrf_temp")) %>%
    # remove anything with m in it; will go back in original code and not create 
    # this to begin with
    select(-contains("_m")) %>% 
    # convert to matrix
    as.matrix()
  # end part to remove------
  
  # calculation of basis ----
  # define basis using natural spline function from "splines"" package
  pm_b <- splines::ns(0:(ncol(pm_matrix)-1), df=pm_df, intercept=T)
  # create pm basis
  pm_basis <- pm_matrix %*% pm_b
  # create temp basis
  temp_b <- splines::ns(0:(ncol(temp_matrix)-1), df=temp_df, intercept=T)
  temp_basis <- temp_matrix %*% temp_b
  # fit model with basis ----
  mod <- clogit(outcome ~ pm_basis + temp_basis + strata(personkey),
    data = complete_data)

  # calculate estimates ----
  # output pm basis parameters
  dl_parms <- broom::tidy(mod) %>% 
    filter(stringr::str_detect(term, "pm")) %>% 
    select(estimate) %>% 
    as_vector()
  # estimate distributed lag values for each day
  estimate <-  pm_b %*% dl_parms
  # covariance matrix for knots 
  # fix the matrix
  cov_matrix <- as.matrix(vcov(mod))[1:pm_df,1:pm_df]
  # estimate variance of spline
  variance <- pm_b %*% cov_matrix %*% t(pm_b)
  # estimate standard error
  se <- sqrt(diag(variance))
  # calculate lower and upper bound
  lower95 <- estimate+(se*qnorm(1-0.975))
  upper95 <- estimate+(se*qnorm(0.975))
  # time variable
  time <- ((rep(1:length(estimate))-1))
  
    if(cumulative==T) {
      type <- rep("cumulative", times = length(estimate))
      # sequential cumulative estimate
      cumulative_estimate <- sapply(seq_along(estimate), function(x){
        sum(estimate[1:x])
      })
      # stderr cumulative effect
      cumulative_se <- sapply(seq_along(estimate), function(x){
        sqrt(sum(variance[1:x,1:x]))
      })
      # cumulative 95CI
      lower95 <- cumulative_estimate+(cumulative_se*qnorm(1-0.975))
      upper95 <- cumulative_estimate+(cumulative_se*qnorm(0.975))
      # return dataframe
      return_estimate <- data.frame(type, time, exp(cumulative_estimate), 
                                    exp(lower95), exp(upper95)) 
      # assign column names
      colnames(return_estimate) <- c("type","time","estimate","lower95","upper95") 

      return(return_estimate)
    } else { # if cumulative is not true, or false, return distributed lag est
    type <- rep("lag", times = length(estimate))
    # return dataframe
    return_estimate <- data.frame(type, time, exp(estimate), 
                                  exp(lower95), exp(upper95)) 
    # assign column names
    colnames(return_estimate) <- c("type","time","estimate","lower95","upper95") 
    # return estimate  
    return(return_estimate)
    } # end of if
} 
```

## Finding smoke distributed lag fit based on AIC

This chunk of code uses the dl_fit function I created to find the degrees of freedom for the natural spline that has the lowest AIC for degrees of freem from 2 to 5 for the smoke lag function. I set temperature degrees of freedom to 2. 

```{r smk aic fit}
fit_df <- cvd_over65_list %>% 
  purrr::map_df(~dl_fit(., pm_df = c(2:5), temp_df =2)) %>% 
  cbind(names(cvd_over65_list), .) 

# add degrees of freedom as a slot to the outcomes list
degfreedom_list <- as.list(fit_df$pm_df)

# dl fit 
knitr::kable(fit_df, caption = paste0("Smoke natural spline degrees of freedom",
                                      " knots based on lowest AIC"))
```

## Distributed Lag Cumulative Effect

Calculating the cumulative effect sequentially (0, 0+1, 0+1+2, ....).

```{r cumulative effect sequential}
cumulative_cvd <- purrr::map2(.x = cvd_over65_list, .y = degfreedom_list, 
  ~distributed_lag(data = .x, pm_df = .y, temp_df = 2, cumulative = T)) %>% 
  plyr::rbind.fill() %>% 
  bind_cols(., data_frame(rep(outcome_names, each=8))) %>% 
  rename(outcome_names = `rep(outcome_names, each = 8)`) %>% 
  select(outcome_names, type, time, estimate, lower95, upper95) %>% 
  # preserve order of names
  mutate(outcome_names = parse_factor(outcome_names, levels = outcome_names))
```

Plotting the cumulative effect of wildfire smoke lags 0 to 7 days for cardiovascular endpoints in persons over 65.

```{r cumulative plot}
#plot 
cumulative_plot <- ggplot(cumulative_cvd, aes(x=time, y=estimate)) +
  geom_line(colour = "#046C9A", size = 1) +
  geom_ribbon(aes(ymin = lower95, ymax = upper95), 
              fill = "#ABDDDE", alpha = 0.5) + 
  scale_x_continuous(breaks = c(seq(0,7, by=1))) +
  geom_hline(yintercept = 1, linetype = 2, colour = "red") +
  facet_wrap(~outcome_names) +
  ylab(expression("Odd ratio for a 10 ug/m^3 increase smoke PM"[2.5])) +
  xlab("Lagged Days") +
  theme(panel.background = element_rect(fill = 'white', colour = 'black'),
    strip.text = element_text(size = 10),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.background = element_rect(colour=NA, fill=NA))

cumulative_plot
```

Estimates of daily distributed lag for CVD outcomes in over 65 age group.

```{r distributed lag estimates}
dl_cvd <- purrr::map2(.x = cvd_over65_list, .y = degfreedom_list, 
  ~distributed_lag(data = .x, pm_df = .y, temp_df = 2, cumulative = F)) %>% 
  plyr::rbind.fill() %>% 
  bind_cols(., data_frame(rep(outcome_names, each=8))) %>% 
  rename(outcome_names = `rep(outcome_names, each = 8)`) %>% 
  select(outcome_names, type, time, estimate, lower95, upper95) %>% 
  # preserve order of names
  mutate(outcome_names = parse_factor(outcome_names, levels = outcome_names))
```

Distributed lag plot.

```{r dl plot}
dl_plot <- ggplot(dl_cvd, aes(x=time, y=estimate)) +
  geom_line(colour = "#6a3093", size = 1) +
  geom_ribbon(aes(ymin = lower95, ymax = upper95), 
              fill = "#6a3093", alpha = 0.5) + 
  scale_x_continuous(breaks = c(seq(0,7, by=1))) +
  geom_hline(yintercept = 1, linetype = 2, colour = "red") +
  facet_wrap(~outcome_names) +
  ylab(expression("Odd ratio for a 10 ug/m^3 increase smoke PM"[2.5])) +
  xlab("Lagged Days") +
  theme(panel.background = element_rect(fill = 'white', colour = 'black'),
    strip.text = element_text(size = 10),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.background = element_rect(colour=NA, fill=NA))

dl_plot
```

